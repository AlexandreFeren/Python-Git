
'''
constantly run this, awaiting commands for version control.
'''
import sys
import os
from glob import glob
from types import FunctionType as function
import warnings
from text_colors import *

import Initialization.init as init
import Initialization.hash_object as hash_object

import Tracking_Changes.ls_tree as ls_tree
import Tracking_Changes.add as add
import Tracking_Changes.status as status



class Main:
    '''
    functions considering adding and rough groupings:
    
    initialization/info
        - init
        - clone

    info
        - diff
        - show
        - help
        - log
        - blame
        
    file moves
        - add
        - mv
        - rm
    
    interact with remote
        - reset
        - restore
        - fetch
        - commit
        - remote
        - pull
        
    branching
        - branch
        - checkout
        - merge
        - stash
        
    change cleanup
        - rebase

    under the hood
        - blob creation (on add)
    '''
    def __init__(self):
        
        # Collect all *.py within subdirectories of Source/ which are not test_*.py
        # small section of autogenerated code:
        # adds entries to self.commands for each file in Source/
        # using the format  
        #   'filename' = filename.filename,
        PATH = os.path.dirname(os.path.realpath(__file__))
        self.commands = {}
        
        result = [y for x in os.walk(PATH) for y in glob(os.path.join(x[0], '*.py'))]
        result = [i.split('\\')[-1][:-3] for i in result
                    if (i.split('\\')[-1][0] != '_' 
                        and i.split('\\')[-1][:5] != 'test_'
                        and len(i.split('\\')) > len(PATH.split('\\'))+1)]
        for fn in result: exec("self.commands['{0}'] = {0}.{0}".format(fn))

    def call_command(self, args):
        path = os.path.dirname(os.path.realpath(__file__))
        if args[0] in self.commands:
            if callable(self.commands[args[0]]):
                self.commands[args[0]](args)
            else: 
                print(type(self.commands[args[0]]))
                warnings.warn(b_colors.WARNING + "Function '{}' not implemented".format(args[0]) + b_colors.END_C)
        else: warnings.warn(b_colors.WARNING + "Command '{}' not found".format(args[0]) + b_colors.END_C)

if __name__ == '__main__':#
    main = Main()
    if len(sys.argv) > 1:
        print(sys.argv)
        main.call_command(sys.argv[1:])
