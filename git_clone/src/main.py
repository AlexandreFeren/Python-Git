import sys, os, warnings, argparse
from glob import glob
from git_clone.src.text_colors import *
class Main:
    '''
    functions considering adding and rough groupings:
        initialization/info
            - init, clone
        info
            - diff, show, help, log, blame
        file moves
            - add, mv, rm
        interact with remote
            - reset, restore, fetch, commit, remote, pull
        branching
            - branch, checkout, merge, stash
        change cleanup
            - rebase
        under the hood
            - blob creation (on add)
    '''
    def __init__(self):
        ############################################
        #     THIS CONTAINS AUTOGENERATED CODE     #
        ############################################

        # Collect all *.py within subdirectories of Source/ which are not test_*.py
        # adds entries to self.commands for each file in Source/ using the format
        #   'filename' = filename.filename,
        PATH = os.path.dirname(os.path.realpath(__file__))
        PATH_LEN = len(PATH.split("\\"))
        self.commands = {}
        #TODO: get the exclude list from .gitignore
        exclude = set([ "__pycache__",
                        "__init__.py",
                        "main.py",
                        "command_line.py",
                        "text_colors.py",
                        ".git"])
        result = []
        for root, dirs, files in os.walk(PATH, topdown=True):
            dirs[:] = [d for d in dirs if d not in exclude]
            result.extend([root.split("\\")[PATH_LEN:] + [f] for f in files if f not in exclude])

        for path in result:
            print('import git_clone.src.{0}.{1} as {1}'.format(".".join(path[:-1]),path[-1][:-3]))
            exec("import git_clone.src.{0}.{1} as {1}".format(".".join(path[:-1]),path[-1][:-3]))
        for fn in result:
            exec("self.commands['{0}'] = {1}.{1}".format(fn[-1][:-3].replace("_","-"),fn[-1][:-3]))

    def call_command(self, args):
        path = os.path.dirname(os.path.realpath(__file__))
        if args[0] in self.commands:
            if callable(self.commands[args[0]]): self.commands[args[0]](args)
            else:
                print(type(self.commands[args[0]]))
                warnings.warn(b_colors.WARNING + "Function '{}' not implemented".format(args[0]) + b_colors.END_C)
        else: warnings.warn(b_colors.WARNING + "Command '{}' not found".format(args[0]) + b_colors.END_C)

if __name__ == '__main__':
    main = Main()
    if len(sys.argv) > 1: main.call_command(sys.argv[1:])
